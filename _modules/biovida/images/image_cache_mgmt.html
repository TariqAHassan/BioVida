<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>biovida.images.image_cache_mgmt &#8212; BioVida 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootswatch-3.3.6/simplex/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          BioVida</a>
        <span class="navbar-text navbar-version pull-left"><b>0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://github.com/TariqAHassan/BioVida">View on GitHub</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../GettingStarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GettingStarted.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GettingStarted.html#dependencies">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GettingStarted.html#image-data">Image Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../GettingStarted.html#cancer-imaging-archive">Cancer Imaging Archive</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../GettingStarted.html#open-i-biomedical-image-search-engine">Open-i BioMedical Image Search Engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../GettingStarted.html#automated-image-data-cleaning">Automated Image Data Cleaning</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../GettingStarted.html#genomic-data">Genomic Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../GettingStarted.html#data-harvesting">Data Harvesting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../GettingStarted.html#exploring-available-databases">Exploring Available Databases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../GettingStarted.html#diagnostic-data">Diagnostic Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../GettingStarted.html#id1">Data Harvesting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../API.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../API.html#module-biovida.images.openi_interface">Images</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#open-i-interface">Open-i Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#cancer-imaging-archive-interface">Cancer Imaging Archive Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#image-processing">Image Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#image-classification">Image Classification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#template-matching">Template Matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#border-and-edge-detection">Border and Edge Detection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../API.html#module-biovida.genomics.disgenet_interface">Genomics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#disgenet-interface">DisGeNET Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../API.html#module-biovida.diagnostics.disease_ont_interface">Diagnostics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#disease-ontology-interface">Disease Ontology Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#disease-symptoms-interface">Disease-Symptoms Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../API.html#module-biovida.unification.unify_domains">Domain Integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#unifying-across-domains">Unifying Across Domains</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../API.html#module-biovida.images.image_cache_mgmt">Cache Manipulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#image-cache-management">Image Cache Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../API.html#module-biovida.support_tools.utilities">Support Tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#utilities">Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../API.html#printing-tools">Printing Tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Current Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">
        </div>
      </div>
    <div class="col-md-9 content">
      
  <h1>Source code for biovida.images.image_cache_mgmt</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Image Cache Management</span>
<span class="sd">    ~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Imports</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>

<span class="c1"># General Image Support Tools</span>
<span class="kn">from</span> <span class="nn">biovida.images._image_tools</span> <span class="k">import</span> <span class="n">ActionVoid</span>

<span class="c1"># General Support Tools</span>
<span class="kn">from</span> <span class="nn">biovida.support_tools.support_tools</span> <span class="k">import</span> <span class="n">cln</span>
<span class="kn">from</span> <span class="nn">biovida.support_tools.support_tools</span> <span class="k">import</span> <span class="n">multimap</span>
<span class="kn">from</span> <span class="nn">biovida.support_tools.support_tools</span> <span class="k">import</span> <span class="n">directory_existence_handler</span>

<span class="c1"># Utilities</span>
<span class="kn">from</span> <span class="nn">biovida.support_tools.utilities</span> <span class="k">import</span> <span class="n">train_val_test</span>
<span class="kn">from</span> <span class="nn">biovida.support_tools.utilities</span> <span class="k">import</span> <span class="n">_file_paths_dict_to_ndarrays</span>

<span class="c1"># Import Printing Tools</span>
<span class="kn">from</span> <span class="nn">biovida.support_tools</span> <span class="k">import</span> <span class="n">pandas_pprint</span>


<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Relationship Mapping Function</span>
<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">_openi_image_relation_map</span><span class="p">(</span><span class="n">data_frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Algorithm to find the index of rows which reference</span>
<span class="sd">    the same image in the cache (the image size can vary).</span>

<span class="sd">    :param data_frame:</span>
<span class="sd">    :type data_frame: ``Pandas DataFrame``</span>
<span class="sd">    :return:</span>
<span class="sd">    :rtype: ``Pandas DataFrame``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy the data_frame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Reset the index</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Get duplicated img_large occurrences. Use of &#39;img_large&#39; is arbitrary, could have used</span>
    <span class="c1"># any of the &#39;img_...&#39; columns, e.g., &#39;img_thumb&#39; or &#39;img_grid150&#39;.</span>
    <span class="n">duplicated_image_refs</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;img_large&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get the indices of duplicates</span>
    <span class="n">dup_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;img_large&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">duplicated_image_refs</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">related</span><span class="p">(</span><span class="n">image_large</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to look for references to the same image in the cache.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">image_large</span> <span class="ow">in</span> <span class="n">dup_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dup_index</span><span class="p">[</span><span class="n">image_large</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">index</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

    <span class="c1"># Apply `relate()`</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;shared_image_ref&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">related</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;img_large&#39;</span><span class="p">],</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">df</span>


<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Merging New Records with the Existing Cache</span>
<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">_dict_to_tot</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Convert a dictionary to a tuple of tuples and sort by the former keys.</span>

<span class="sd">    :param d: any dictionary.</span>
<span class="sd">    :type d: ``dict``</span>
<span class="sd">    :return: ``d`` as a tuple of tuples, sorted by the former key values.</span>
<span class="sd">    :rtype: ``tuple``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">values_to_tuples</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">values_to_tuples</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>


<span class="k">def</span> <span class="nf">_record_update_dbs_joiner</span><span class="p">(</span><span class="n">records_db</span><span class="p">,</span> <span class="n">update_db</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Join and drop rows for which `update_db`&#39;s columns exclusively contain NaNs.</span>

<span class="sd">    :param records_db: permanent database/dataframe which keeps a record of files in the cache.</span>
<span class="sd">    :type records_db: ``Pandas DataFrame``</span>
<span class="sd">    :param update_db: database/dataframe to &#39;update&#39; ``records_db``</span>
<span class="sd">    :type update_db: ``Pandas DataFrame``</span>
<span class="sd">    :return: ``records_db`` with ``update_db`` left-joined.</span>
<span class="sd">    :rtype: ``Pandas DataFrame``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">joined_db</span> <span class="o">=</span> <span class="n">records_db</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">update_db</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">joined_db</span> <span class="o">=</span> <span class="n">records_db</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">update_db</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">joined_db</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">update_db</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">joined_db</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">update_db</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_load_temp_dbs</span><span class="p">(</span><span class="n">temp_db_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Load temporary databases in the &#39;databases/__temp__&#39; directory.</span>

<span class="sd">    :param temp_db_path: path to the temporary databases (must be pickled and use the &#39;.p&#39; extension).</span>
<span class="sd">    :type temp_db_path: ``str``</span>
<span class="sd">    :return: all of the &#39;.p&#39; dataframes in ``temp_db_path`` merged into a single dataframe.</span>
<span class="sd">    :rtype: ``Pandas DataFrame`` or ``None``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get pickled objects in ``temp_db_path``</span>
    <span class="n">db_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_db_path</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">temp_db_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.p&quot;</span><span class="p">)]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">db_paths</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Set of to group db_paths by</span>
    <span class="n">unique_pull_times</span> <span class="o">=</span> <span class="p">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">db_paths</span><span class="p">}</span>

    <span class="n">groupings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">pull_time</span> <span class="ow">in</span> <span class="n">unique_pull_times</span><span class="p">:</span>
        <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">db_paths</span> <span class="k">if</span> <span class="n">pull_time</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;FileNotFoundError: Either &#39;</span><span class="si">{0}</span><span class="s2">__records_db.p&#39; or &#39;</span><span class="si">{0}</span><span class="s2">__update_db.p&#39;&quot;</span>
                 <span class="s2">&quot; is missing from</span><span class="se">\n</span><span class="s2"> </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">Deleting the file which is present...</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="s2">&quot;As a result, images obtained from the last `pull()` will likely be missing&quot;</span>
                 <span class="s2">&quot; from `cache_records_db`.</span><span class="se">\n</span><span class="s2">For this reason, it is recommended that you</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="s2">&quot;**precisely** repeat your last `search()` and `pull()`.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pull_time</span><span class="p">,</span> <span class="n">temp_db_path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groupings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">groupings</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Read the dataframes in the &#39;__temp__&#39; directory into memory</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groupings</span><span class="p">:</span>
        <span class="n">records_db</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span> <span class="k">if</span> <span class="s2">&quot;__records_db.p&quot;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">update_db</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span> <span class="k">if</span> <span class="s2">&quot;__update_db.p&quot;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_record_update_dbs_joiner</span><span class="p">(</span><span class="n">records_db</span><span class="p">,</span> <span class="n">update_db</span><span class="p">))</span>

    <span class="c1"># Concatenate all frames</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_relationship_mapper</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">interface_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param data_frame:</span>
<span class="sd">    :type data_frame: ``Pandas DataFrame``</span>
<span class="sd">    :param interface_name:</span>
<span class="sd">    :type interface_name: ``str``</span>
<span class="sd">    :return:</span>
<span class="sd">    :rtype: ``Pandas DataFrame``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_relationship_mapping_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Keys: Interface Class Name.</span>
        <span class="c1"># Values: mapping function</span>
        <span class="s1">&#39;OpeniInterface&#39;</span><span class="p">:</span> <span class="n">_openi_image_relation_map</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">interface_name</span> <span class="ow">in</span> <span class="n">_relationship_mapping_dict</span><span class="p">:</span>
        <span class="n">relationship_mapping_func</span> <span class="o">=</span> <span class="n">_relationship_mapping_dict</span><span class="p">[</span><span class="n">interface_name</span><span class="p">]</span>
        <span class="n">data_frame</span> <span class="o">=</span> <span class="n">relationship_mapping_func</span><span class="p">(</span><span class="n">data_frame</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_frame</span>


<span class="k">def</span> <span class="nf">_records_db_merge</span><span class="p">(</span><span class="n">interface_name</span><span class="p">,</span>
                      <span class="n">current_records_db</span><span class="p">,</span>
                      <span class="n">records_db_update</span><span class="p">,</span>
                      <span class="n">columns_with_dicts</span><span class="p">,</span>
                      <span class="n">duplicates_subset_columns</span><span class="p">,</span>
                      <span class="n">rows_to_conserve_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">post_concat_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">columns_with_iterables_to_sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Merge the existing record database with new additions.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Both ``current_records_db`` and ``records_db_update`` are expected to have &#39;pull_time&#39; columns.</span>

<span class="sd">    :param current_records_db: the existing record database.</span>
<span class="sd">    :type current_records_db: ``Pandas DataFrame``</span>
<span class="sd">    :param records_db_update: the new records dataframe to be merged with the existing one (``current_records_db``).</span>
<span class="sd">    :type records_db_update: ``Pandas DataFrame``</span>
<span class="sd">    :param columns_with_dicts: a list of columns which contain dictionaries. Note: this column *should* contain only</span>
<span class="sd">                               dictionaries or NaNs.</span>
<span class="sd">    :type columns_with_dicts: ``list``, ``tuple`` or ``None``.</span>
<span class="sd">    :param duplicates_subset_columns: a list (or tuple) of columns to consider when dropping duplicates.</span>

<span class="sd">                    .. warning::</span>

<span class="sd">                            Do *not* include the &#39;shared_image_ref&#39; column as this function will recompute it.</span>

<span class="sd">    :type duplicates_subset_columns: ``list`` or ``tuple``</span>
<span class="sd">    :param rows_to_conserve_func: function to generate a list of booleans which denote whether or not the image is,</span>
<span class="sd">                                  in fact, present in the cache. If not, remove it from the database to be saved.</span>
<span class="sd">    :type rows_to_conserve_func: ``function``</span>
<span class="sd">    :param post_concat_func: a function to apply to ``combined_dbs`` after it is generated.</span>
<span class="sd">                             This function should accept and return a dataframe.</span>
<span class="sd">    :type post_concat_func: ``function``</span>
<span class="sd">    :param columns_with_iterables_to_sort: columns which themselves contain lists or tuples which should be sorted</span>
<span class="sd">                                  prior to dropping. Defaults to ``None``.</span>
<span class="sd">    :type columns_with_iterables_to_sort: ``list`` or ``tuple``</span>
<span class="sd">    :return: a dataframe which merges ``current_records_db`` and ``records_db_update``</span>
<span class="sd">    :rtype: ``Pandas DataFrame``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: this function does not explicitly handle cases where combined_dbs has length 0, no obvious need to though.</span>
    <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">current_records_db</span><span class="p">,</span> <span class="n">records_db_update</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Mark each row to conserve order following ``pandas.drop_duplicates()``.</span>
    <span class="n">combined_dbs</span><span class="p">[</span><span class="s1">&#39;__temp_order__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">combined_dbs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">rows_to_conserve_func</span><span class="p">):</span>
        <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">combined_dbs</span><span class="p">[</span><span class="n">combined_dbs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">rows_to_conserve_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">post_concat_func</span><span class="p">):</span>
        <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">post_concat_func</span><span class="p">(</span><span class="n">combined_dbs</span><span class="p">)</span>

    <span class="c1"># Note: Typically these will be &#39;in sync&#39;. However, if they are not, preference is given</span>
    <span class="c1"># to &#39;biovida_version&#39; s.t. the data harvested with the latest version is given preference.</span>
    <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">combined_dbs</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;biovida_version&#39;</span><span class="p">,</span> <span class="s1">&#39;pull_time&#39;</span><span class="p">])</span>

    <span class="c1"># Convert items in ``columns_with_dicts`` from dictionaries to tuple of tuples.</span>
    <span class="c1"># (making them hashable, as required by ``pandas.drop_duplicates()``).</span>
    <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">multimap</span><span class="p">(</span><span class="n">combined_dbs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns_with_dicts</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_dict_to_tot</span><span class="p">)</span>

    <span class="c1"># Sort iterables in columns with iterables</span>
    <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">multimap</span><span class="p">(</span><span class="n">combined_dbs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns_with_iterables_to_sort</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="c1"># Drop Duplicates (keeping the most recent).</span>
    <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">combined_dbs</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">duplicates_subset_columns</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)</span>

    <span class="c1"># Convert the tuples back to dictionaries</span>
    <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">multimap</span><span class="p">(</span><span class="n">combined_dbs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns_with_dicts</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="c1"># Sort against the original order.</span>
    <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">combined_dbs</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;__temp_order__&#39;</span><span class="p">)</span>

    <span class="c1"># Map relationships in the dataframe.</span>
    <span class="n">combined_dbs</span> <span class="o">=</span> <span class="n">_relationship_mapper</span><span class="p">(</span><span class="n">data_frame</span><span class="o">=</span><span class="n">combined_dbs</span><span class="p">,</span> <span class="n">interface_name</span><span class="o">=</span><span class="n">interface_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">combined_dbs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;__temp_order__&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Pruning the Cache of Deleted Files</span>
<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">_files_existence_checker</span><span class="p">(</span><span class="n">to_check</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Checks if ``to_check`` exists.</span>
<span class="sd">    If not take the following action:</span>

<span class="sd">    - If a ``str``, return ``to_check`` if it exists else ``None``.</span>

<span class="sd">    - If a ``list`` or ``tuple``, remove items that do not exist.</span>
<span class="sd">      If resultant length is zero return ``None``.</span>

<span class="sd">    :param to_check: file, or iterable of file, to check the existence of</span>
<span class="sd">    :type to_check: ``str``, ``list`` or ``tuple``</span>
<span class="sd">    :return: ``to_check``, pruned ``to_check`` (if iterable) or ``None`` (all files removed).</span>
<span class="sd">    :rtype: ``str``, ``list``, ``tuple``, ``None`` or ``type(to_check)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_check</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">to_check</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">to_check</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_check</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">files_present</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_check</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">files_present</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files_present</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">to_check</span>


<span class="k">def</span> <span class="nf">_df_pruner</span><span class="p">(</span><span class="n">cache_records_db</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Prune ``cache_records_db`` by reviewing ``columns``.</span>

<span class="sd">    :param cache_records_db: see ``_prune_rows_with_deleted_images()``.</span>
<span class="sd">    :type cache_records_db: ``Pandas DataFrame``</span>
<span class="sd">    :param columns: see ``_prune_rows_with_deleted_images()``.</span>
<span class="sd">    :type columns: ``list``</span>
<span class="sd">    :return: a pruned ``cache_records_db``.</span>
<span class="sd">    :rtype: ``Pandas DataFrame``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
        <span class="n">cache_records_db</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache_records_db</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_files_existence_checker</span><span class="p">)</span>

    <span class="c1"># Mark rows to remove</span>
    <span class="n">indices_to_drop</span> <span class="o">=</span> <span class="n">cache_records_db</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Drop and reset the index</span>
    <span class="k">return</span> <span class="n">cache_records_db</span><span class="p">[</span><span class="n">indices_to_drop</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prune_rows_with_deleted_images</span><span class="p">(</span><span class="n">cache_records_db</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">save_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Tool to remove reference to images that have been manually deleted from the cache.</span>
<span class="sd">    After this pruning has occurred, ``cache_records_db`` is saved at ``save_path``.</span>

<span class="sd">    If a column element is a string, it will be left &#39;as is&#39; if the file exists,</span>
<span class="sd">    otherwise it the entire row will be marked for deletion.</span>

<span class="sd">    If a column element is a tuple, image paths in the tuple that do not exist will be removed from the</span>
<span class="sd">    tuple. If the resultant tuple is of zero length (i.e., all images have been deleted), the entire row</span>
<span class="sd">    will be marked for deletion.</span>

<span class="sd">    If, for a given row, all entries for the columns in ``columns`` are ``None`` (i.e., the images</span>
<span class="sd">    have been deleted), that row will be removed from ``cache_records_db``.</span>
<span class="sd">    Note: if one column is marked for deletion and another is not, the row will be conserved.</span>

<span class="sd">    .. note::</span>

<span class="sd">        If no images have been deleted, the output of this function will be the same as the input.</span>

<span class="sd">    :param cache_records_db: a cache_records_db from the ``OpeniInterface()`` or ``CancerImageInterface()``</span>
<span class="sd">    :type cache_records_db: ``Pandas DataFrame``</span>
<span class="sd">    :param columns: a ``list`` of columns with paths to cached images. These columns can be columns of</span>
<span class="sd">                    strings or columns of tuples.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This parameter *must* be a ``list``.</span>

<span class="sd">    :type columns: ``list``</span>
<span class="sd">    :param save_path: the location to save ``cache_records_db``.</span>
<span class="sd">    :type save_path: ``str``</span>
<span class="sd">    :return: a pruned ``cache_records_db``</span>
<span class="sd">    :rtype: ``Pandas DataFrame``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pruned_cache_records_db</span> <span class="o">=</span> <span class="n">_df_pruner</span><span class="p">(</span><span class="n">cache_records_db</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
    <span class="n">pruned_cache_records_db</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pruned_cache_records_db</span>


<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Interface Data</span>
<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>


<span class="n">_image_instance_image_columns</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Note: the first item should be the default.</span>
    <span class="s1">&#39;OpeniInterface&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;cached_images_path&#39;</span><span class="p">,),</span>
    <span class="s1">&#39;ImageProcessing&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;cached_images_path&#39;</span><span class="p">,),</span>
    <span class="s1">&#39;unify_against_images&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;cached_images_path&#39;</span><span class="p">,),</span>
    <span class="s1">&#39;CancerImageInterface&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;cached_images_path&#39;</span><span class="p">,</span> <span class="s1">&#39;cached_dicom_images_path&#39;</span><span class="p">)</span>
<span class="p">}</span>


<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Deleting Image Data</span>
<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">_robust_delete</span><span class="p">(</span><span class="n">to_delete</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Function to delete ``to_delete``.</span>
<span class="sd">    If a list (or tuple), all paths therein will be deleted.</span>

<span class="sd">    :param to_delete: a file, or multiple files to delete. Note: if ``to_delete`` is not a ``string``,</span>
<span class="sd">                     ``list`` or ``tuple``, no action will be taken.</span>
<span class="sd">    :type to_delete: ``str``, ``list``  or ``tuple``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">delete_file</span><span class="p">(</span><span class="n">td</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">td</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">td</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_delete</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">delete_file</span><span class="p">(</span><span class="n">to_delete</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_delete</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">to_delete</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">delete_file</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_double_check_with_user</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Ask the user to verify they wish to proceed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">response</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;This action cannot be undone.</span><span class="se">\n</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;Do you wish to continue (y/n)?&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cln</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="s1">&#39;ye&#39;</span><span class="p">,</span> <span class="s1">&#39;es&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ActionVoid</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Action Canceled.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pretty_print_image_delete</span><span class="p">(</span><span class="n">deleted_rows</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Pretty print ``deleted_rows``.</span>

<span class="sd">    :param deleted_rows: as evolved inside ``image_delete``.</span>
<span class="sd">    :type deleted_rows: ``dict``</span>
<span class="sd">    :param verbose: see ``image_delete``.</span>
<span class="sd">    :type verbose: ``bool``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deleted_rows</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Indices of Deleted Rows:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">to_print</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">deleted_rows</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># handles when values are of unequal length.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_print</span><span class="p">):</span>
            <span class="n">pandas_pprint</span><span class="p">(</span><span class="n">to_print</span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">to_print</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)],</span> <span class="n">full_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suppress_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">No Rows Deleted.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="image_delete"><a class="viewcode-back" href="../../../source/biovida.html#biovida.images.image_cache_mgmt.image_delete">[docs]</a><span class="k">def</span> <span class="nf">image_delete</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">delete_rule</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Delete images from the cache.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        The effects of this function can only be undone by downloading the deleted data again.</span>

<span class="sd">    :param instance: an instance of ``OpeniInterface`` or ``CancerImageInterface``.</span>
<span class="sd">    :type instance: ``OpeniInterface`` or ``CancerImageInterface``</span>
<span class="sd">    :param delete_rule: must be one of: ``&#39;all&#39;`` (delete *all* data) or a ``function`` which (1) accepts a single</span>
<span class="sd">                        parameter (argument) and (2) returns ``True`` when the data is to be deleted.</span>
<span class="sd">    :type delete_rule: ``str`` or ``function``</span>
<span class="sd">    :param verbose: if ``True``, print additional information.</span>
<span class="sd">    :type verbose: ``bool``</span>
<span class="sd">    :return: a dictionary of the indices which were dropped. Example: ``{&#39;records_db&#39;: [58, 59], &#39;cache_records_db&#39;: [158, 159]}``.</span>
<span class="sd">    :rtype: ``dict``</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from biovida.images import image_delete</span>
<span class="sd">    &gt;&gt;&gt; from biovida.images import OpeniInterface</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; opi = OpeniInterface()</span>
<span class="sd">    &gt;&gt;&gt; opi.search(image_type=[&#39;ct&#39;, &#39;mri&#39;], collection=&#39;medpix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; opi.pull()</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def my_delete_rule(row):</span>
<span class="sd">    &gt;&gt;&gt;     if isinstance(row[&#39;abstract&#39;], str) and &#39;Oompa Loompas&#39; in row[&#39;abstract&#39;]:</span>
<span class="sd">    &gt;&gt;&gt;         return True</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; image_delete(opi, delete_rule=my_delete_rule)</span>

<span class="sd">    .. note::</span>

<span class="sd">        In this example, any rows in the ``records_db`` and ``cache_records_db``</span>
<span class="sd">        for which the &#39;abstract&#39; column contains the string &#39;Oompa Loompas&#39; will be deleted.</span>
<span class="sd">        Any images associated with this row will also be destroyed.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        If a function is passed to ``delete_rule`` it *must* return a boolean ``True`` to delete a row.</span>
<span class="sd">        **All other output will be ignored**.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ToDo: refactor. This function is very cumbersome.</span>
    <span class="n">index_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">_double_check_with_user</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deleting...&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delete_rule</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cln</span><span class="p">(</span><span class="n">delete_rule</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">delete_all</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`delete_rule` must be &#39;all&#39; or a `function`.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">delete_all</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">image_columns</span> <span class="o">=</span> <span class="n">_image_instance_image_columns</span><span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">delete_rule_wrapper</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">enact</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap delete_rule to ensure the output is a boolean.&quot;&quot;&quot;</span>
        <span class="n">do_delete</span> <span class="o">=</span> <span class="n">delete_rule</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">delete_rule</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">delete_all</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">do_delete</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">do_delete</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">enact</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">image_columns</span><span class="p">:</span>
                    <span class="n">_robust_delete</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># drop row from the dataframe</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>   <span class="c1"># keep row in the dataframe</span>

    <span class="k">def</span> <span class="nf">index_dict_update</span><span class="p">(</span><span class="n">data_frame_name</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">data_frame</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s1">&#39;before&#39;</span><span class="p">:</span>
            <span class="n">index_dict</span><span class="p">[</span><span class="n">data_frame_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">stage</span><span class="p">:</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="n">stage</span> <span class="o">==</span> <span class="s1">&#39;after&#39;</span><span class="p">:</span>
            <span class="n">index_dict</span><span class="p">[</span><span class="n">data_frame_name</span><span class="p">][</span><span class="n">stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">non_cache_db</span><span class="p">(</span><span class="n">data_frame_name</span><span class="p">,</span> <span class="n">data_frame</span><span class="p">,</span> <span class="n">enact</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle `records_db` and `image_dataframe`.&quot;&quot;&quot;</span>
        <span class="n">index_dict_update</span><span class="p">(</span><span class="n">data_frame_name</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;before&#39;</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">data_frame</span><span class="p">)</span>
        <span class="n">to_conserve</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">delete_rule_wrapper</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">enact</span><span class="o">=</span><span class="n">enact</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_frame</span> <span class="o">=</span> <span class="n">data_frame</span><span class="p">[</span><span class="n">to_conserve</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">index_dict_update</span><span class="p">(</span><span class="n">data_frame_name</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">data_frame</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_frame</span><span class="p">,</span> <span class="n">to_conserve</span>

    <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;ImageProcessing&#39;</span><span class="p">:</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">image_dataframe</span><span class="p">,</span> <span class="n">to_conserve</span> <span class="o">=</span> <span class="n">non_cache_db</span><span class="p">(</span><span class="s1">&#39;image_dataframe&#39;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">image_dataframe</span><span class="p">,</span> <span class="n">enact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">db_to_extract</span> <span class="o">==</span> <span class="s1">&#39;records_db&#39;</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">[</span><span class="n">to_conserve</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">index_dict_update</span><span class="p">(</span><span class="s1">&#39;records_db&#39;</span><span class="p">,</span> <span class="s1">&#39;before&#39;</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">)</span>
            <span class="n">to_conserve</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">[</span><span class="n">image_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">[</span><span class="n">to_conserve</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">index_dict_update</span><span class="p">(</span><span class="s1">&#39;records_db&#39;</span><span class="p">,</span> <span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">index_dict_update</span><span class="p">(</span><span class="s1">&#39;cache_records_db&#39;</span><span class="p">,</span> <span class="s1">&#39;before&#39;</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span><span class="p">)</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">_load_prune_cache_records_db</span><span class="p">(</span><span class="n">load</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">index_dict_update</span><span class="p">(</span><span class="s1">&#39;cache_records_db&#39;</span><span class="p">,</span> <span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`cache_record_db` is not a DataFrame.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">non_cache_db</span><span class="p">(</span><span class="s1">&#39;records_db&#39;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">records_db</span><span class="p">,</span> <span class="n">enact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">index_dict_update</span><span class="p">(</span><span class="s1">&#39;cache_records_db&#39;</span><span class="p">,</span> <span class="s1">&#39;before&#39;</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span><span class="p">)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">delete_rule_wrapper</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">enact</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">_load_prune_cache_records_db</span><span class="p">(</span><span class="n">load</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span> <span class="o">=</span> <span class="n">_relationship_mapper</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">_save_cache_records_db</span><span class="p">()</span>
            <span class="n">index_dict_update</span><span class="p">(</span><span class="s1">&#39;cache_records_db&#39;</span><span class="p">,</span> <span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">cache_records_db</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`cache_record_db` is not a DataFrame.&quot;</span><span class="p">)</span>

    <span class="n">deleted_rows</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;before&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;after&#39;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">_pretty_print_image_delete</span><span class="p">(</span><span class="n">deleted_rows</span><span class="o">=</span><span class="n">deleted_rows</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">deleted_rows</span></div>


<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Divvy Image Data</span>
<span class="c1"># ----------------------------------------------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">_image_divvy_error_checking</span><span class="p">(</span><span class="n">divvy_rule</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">train_val_test_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Check for possible errors for ``image_divvy()``.</span>

<span class="sd">    :param divvy_rule: see ``image_divvy()``.</span>
<span class="sd">    :type divvy_rule: ``str`` or ``function``</span>
<span class="sd">    :param train_val_test_dict: see ``image_divvy()``.</span>
<span class="sd">    :type action: ``str``</span>
<span class="sd">    :param train_val_test_dict: see ``image_divvy()``.</span>
<span class="sd">    :type train_val_test_dict: ``dict``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divvy_rule</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">divvy_rule</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`divvy_rule` must be a string or function.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_val_test_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">train_val_test_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;`train_val_test_dict` is empty&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;copy&#39;</span> <span class="ow">and</span> <span class="s1">&#39;target_dir&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train_val_test_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;`train_val_test_dict` must contain a `target_dir` key &quot;</span>
                           <span class="s2">&quot;if `action=&#39;copy&#39;`.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">train_val_test_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="s1">&#39;validation&#39;</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="s1">&#39;target_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;delete_source&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Invalid `train_val_test_dict` key: &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;ndarray&#39;</span> <span class="ow">and</span> <span class="s1">&#39;target_dir&#39;</span> <span class="ow">in</span> <span class="n">train_val_test_dict</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The &#39;target_dir&#39; entry in `train_val_test_dict` has no</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="s2">&quot;effect when `action=&#39;ndarray&#39;`.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_robust_copy</span><span class="p">(</span><span class="n">to_copy</span><span class="p">,</span> <span class="n">copy_to</span><span class="p">,</span> <span class="n">allow_creation</span><span class="p">,</span> <span class="n">allow_overwrite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Function to copy ``to_copy``.</span>
<span class="sd">    If a list (or tuple), all paths therein will be copied.</span>

<span class="sd">    :param to_copy: a file, or multiple files to delete. Note: if ``to_copy`` is not a ``string``,</span>
<span class="sd">                     ``list`` or ``tuple``, no action will be taken.</span>
<span class="sd">    :type to_copy: ``str``, ``list``  or ``tuple``</span>
<span class="sd">    :param copy_to: the location for the image</span>
<span class="sd">    :type copy_to: ``str``</span>
<span class="sd">    :param allow_creation: if ``True``, create ``path_`` if it does not exist, else raise.</span>
<span class="sd">    :type allow_creation: ``bool``</span>
<span class="sd">    :param allow_overwrite: if ``True`` allow existing images to be overwritten. Defaults to ``True``.</span>
<span class="sd">    :type allow_overwrite: ``bool``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">directory_existence_handler</span><span class="p">(</span><span class="n">path_</span><span class="o">=</span><span class="n">copy_to</span><span class="p">,</span> <span class="n">allow_creation</span><span class="o">=</span><span class="n">allow_creation</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy_util</span><span class="p">(</span><span class="n">from_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">from_path</span><span class="p">):</span>
            <span class="n">to_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">copy_to</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">from_path</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_overwrite</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">to_path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="s2">&quot;The following file already exists:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_path</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">from_path</span><span class="p">,</span> <span class="n">to_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No such file:</span><span class="se">\n</span><span class="s2">&#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">from_path</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_copy</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">copy_util</span><span class="p">(</span><span class="n">from_path</span><span class="o">=</span><span class="n">to_copy</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_copy</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">to_copy</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">copy_util</span><span class="p">(</span><span class="n">from_path</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_divvy_column_selector</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">image_column</span><span class="p">,</span> <span class="n">data_frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Select the column to use when copying images from.</span>

<span class="sd">    :param instance:  see ``image_divvy()``</span>
<span class="sd">    :type instance: ``OpeniInterface`` or ``CancerImageInterface``</span>
<span class="sd">    :param image_column: see ``image_divvy()``</span>
<span class="sd">    :type image_column: ``str``</span>
<span class="sd">    :param data_frame: as evolved inside  ``image_divvy()``.</span>
<span class="sd">    :type data_frame: ``Pandas DataFrame``</span>
<span class="sd">    :return: the column in ``data_frame`` to use when copying images to the new location.</span>
<span class="sd">    :rtype: ``str``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">image_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_image_instance_image_columns</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_column</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`image_column` must be a string or `None`.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">image_column</span> <span class="ow">in</span> <span class="n">_image_instance_image_columns</span><span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">image_column</span> <span class="ow">in</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image_column</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;The &#39;</span><span class="si">{0}</span><span class="s2">&#39; column is missing from the dataframe.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">image_column</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; is not a valid image column.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">image_column</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_image_divvy_wrappers_gen</span><span class="p">(</span><span class="n">divvy_rule</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">train_val_test_dict</span><span class="p">,</span> <span class="n">column_to_use</span><span class="p">,</span> <span class="n">create_dirs</span><span class="p">,</span> <span class="n">allow_overwrite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Wrap the ``divvy_rule`` passed to ``image_divvy()``.</span>

<span class="sd">    :param divvy_rule: see ``image_divvy()``.</span>
<span class="sd">    :type divvy_rule: ``str`` or ``function``</span>
<span class="sd">    :param action: see ``image_divvy()``.</span>
<span class="sd">    :type action: ``str``</span>
<span class="sd">    :param train_val_test_dict:  see ``image_divvy()``.</span>
<span class="sd">    :type train_val_test_dict: ``dict``</span>
<span class="sd">    :param column_to_use:  as evolved inside ``image_divvy`` by ``_divvy_column_selector()``</span>
<span class="sd">    :type column_to_use: ``str``</span>
<span class="sd">    :param create_dirs: see ``image_divvy()``.</span>
<span class="sd">    :type create_dirs: ``bool``</span>
<span class="sd">    :param allow_overwrite: see ``image_divvy()``.</span>
<span class="sd">    :type allow_overwrite: ``bool``</span>
<span class="sd">    :return: a function which wraps the function passed to ``divvy_rule()``.</span>
<span class="sd">    :rtype: ``function``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">copy_rule_wrapper</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">copy_to</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copy_to</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">all_copy_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy_to</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copy_to</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">copy_to</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_copy_targets</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_copy_targets</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`divvy_rule` returned an iterable containing &quot;</span>
                                    <span class="s2">&quot;a element which is not a string.&quot;</span><span class="p">)</span>
                <span class="n">_robust_copy</span><span class="p">(</span><span class="n">to_copy</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="n">column_to_use</span><span class="p">],</span> <span class="n">copy_to</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                             <span class="n">allow_creation</span><span class="o">=</span><span class="n">create_dirs</span><span class="p">,</span> <span class="n">allow_overwrite</span><span class="o">=</span><span class="n">allow_overwrite</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">copy_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;String, list or tuple expected. &quot;</span>
                            <span class="s2">&quot;`divvy_rule` returned an object of type &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copy_to</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">divvy_rule_wrapper</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="n">copy_to</span> <span class="o">=</span> <span class="n">divvy_rule</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">divvy_rule</span><span class="p">)</span> <span class="k">else</span> <span class="n">divvy_rule</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copy_to</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copy_to</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">copy_to</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;copy&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_val_test_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">copy_rule_wrapper</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">copy_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column_to_use</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">cache_info</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">column_to_use</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column_to_use</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column_to_use</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copy_to</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">copy_to</span><span class="p">),</span> <span class="n">cache_info</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copy_to</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">[[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">cache_info</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">copy_to</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">divvy_rule_wrapper</span>


<span class="k">def</span> <span class="nf">_image_divvy_train_val_test_wrapper</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">divvy_info</span><span class="p">,</span> <span class="n">train_val_test_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Take ``divvy_info`` and pass to ``train_val_test()``</span>

<span class="sd">    :param action: see ``image_divvy()``.</span>
<span class="sd">    :type action: ``str``</span>
<span class="sd">    :param verbose: see ``image_divvy()``.</span>
<span class="sd">    :type verbose: ``bool``</span>
<span class="sd">    :param divvy_info: as evolved inside ``image_divvy`` (by ``divvy_info_data_frame_to_dict()``).</span>
<span class="sd">    :type divvy_info: ``dict``</span>
<span class="sd">    :param train_val_test_dict see ``image_divvy()``.</span>
<span class="sd">    :type train_val_test_dict:</span>
<span class="sd">    :return: see ``train_val_test``.</span>
<span class="sd">    :rtype: ``dict``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">train_val_test_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;target_dir&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;copy&#39;</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">random_state</span> <span class="o">=</span> <span class="n">train_val_test_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;random_state&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;copy&#39;</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">delete_source</span> <span class="o">=</span> <span class="n">train_val_test_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;delete_source&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;copy&#39;</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="n">output_dict</span> <span class="o">=</span> <span class="n">train_val_test</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">divvy_info</span><span class="p">,</span>
                                 <span class="n">train</span><span class="o">=</span><span class="n">train_val_test_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;train&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                 <span class="n">validation</span><span class="o">=</span><span class="n">train_val_test_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;validation&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                 <span class="n">test</span><span class="o">=</span><span class="n">train_val_test_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                 <span class="n">target_dir</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">delete_source</span><span class="o">=</span><span class="n">delete_source</span><span class="p">,</span>
                                 <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output_dict</span>


<span class="k">def</span> <span class="nf">_divvy_info_to_dict</span><span class="p">(</span><span class="n">divvy_info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Convert the list evolved inside ``divvy_rule_apply()`` in</span>
<span class="sd">    ``image_divvy()`` into a dictionary</span>

<span class="sd">    :param divvy_info: a list of the form ``[[string_1, [&#39;a&#39;, &#39;b&#39;]], [string_1, [&#39;c&#39;, &#39;d&#39;]], [string_2, [&#39;e&#39;]], ...]``.</span>
<span class="sd">    :type divvy_info: ``list``</span>
<span class="sd">    :return: a dictionary form: ``{string_1: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], string_2: [&#39;e&#39;], ...}``.</span>
<span class="sd">    :rtype: ``Pandas DataFrame``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">divvy_info</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>


<div class="viewcode-block" id="image_divvy"><a class="viewcode-back" href="../../../source/biovida.html#biovida.images.image_cache_mgmt.image_divvy">[docs]</a><span class="k">def</span> <span class="nf">image_divvy</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
                <span class="n">divvy_rule</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="s1">&#39;ndarray&#39;</span><span class="p">,</span>
                <span class="n">db_to_extract</span><span class="o">=</span><span class="s1">&#39;records_db&#39;</span><span class="p">,</span>
                <span class="n">train_val_test_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">create_dirs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">allow_overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">image_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Grouping Cached Images.</span>

<span class="sd">    :param instance: the yield of the yield of ``biovida.unification.unify_against_images()`` or an instance of</span>
<span class="sd">                     ``OpeniInterface``, ``ImageProcessing`` or ``CancerImageInterface``.</span>
<span class="sd">    :type instance: ``OpeniInterface``, ``ImageProcessing``, ``CancerImageInterface`` or ``Pandas DataFrame``</span>
<span class="sd">    :param divvy_rule: must be a `function`` which (1) accepts a single parameter (argument) and (2) return</span>
<span class="sd">                       system path(s) [see example below].</span>
<span class="sd">    :type divvy_rule: ``str`` or ``function``</span>
<span class="sd">    :param action: one of: ``&#39;copy&#39;``, ``&#39;ndarray&#39;``.</span>

<span class="sd">                    - if ``&#39;copy&#39;``: copy from files from the cache to (i) the location prescribed by ``divvy_rule``,</span>
<span class="sd">                      when ``train_val_test_dict=None``, else (ii) the &#39;target_location&#39; key in ``train_val_test_dict``.</span>

<span class="sd">                    - if ``&#39;ndarray&#39;``: return a nested dictionary of ``ndarray`` (&#39;numpy&#39;) arrays (default).</span>

<span class="sd">    :type action: ``str``</span>
<span class="sd">    :param db_to_extract: the database to use. Must be one of:</span>

<span class="sd">                - &#39;records_db&#39;: the dataframe resulting from the most recent ``search()`` &amp; ``pull()`` (default).</span>
<span class="sd">                - &#39;cache_records_db&#39;: the cache dataframe for ``instance``.</span>
<span class="sd">                - &#39;unify_against_images&#39;: the yield of ``biovida.unification.unify_against_images()``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If an instance of ``ImageProcessing`` is passed, the dataframe will be extracted automatically.</span>

<span class="sd">    :type db_to_extract: ``str``</span>
<span class="sd">    :param train_val_test_dict: a dictionary denoting the proportions for any of: ``&#39;train&#39;``, ``&#39;validation&#39;`` and/or ``&#39;test&#39;``.</span>

<span class="sd">                        .. note::</span>

<span class="sd">                            * If ``action=&#39;copy&#39;``, a ``&#39;target_dir&#39;`` key (target directory) *must* also be included.</span>
<span class="sd">                            * A ``&#39;random_state&#39;`` key can be passed, with an integer as the value, to seed shuffling.</span>
<span class="sd">                            * To delete the source files, a ``&#39;delete_source&#39;`` key may be included (optional).</span>
<span class="sd">                              The corresponding value provided *must* be a boolean. If no such key key is provided,</span>
<span class="sd">                              ``&#39;delete_source&#39;`` defaults to ``False``.</span>

<span class="sd">    :type train_val_test_dict: ``None`` or ``dict``</span>
<span class="sd">    :param create_dirs: if ``True``, create directories returned by ``divvy_rule`` if they do not exist. Defaults to ``True``.</span>
<span class="sd">    :type create_dirs: ``bool``</span>
<span class="sd">    :param allow_overwrite: if ``True`` allow existing images to be overwritten. Defaults to ``True``.</span>
<span class="sd">    :type allow_overwrite: ``bool``</span>
<span class="sd">    :param image_column: the column to use when copying images. If ``None``, use ``&#39;cached_images_path&#39;``. Defaults to ``None``.</span>
<span class="sd">    :type image_column: ``str``</span>
<span class="sd">    :param verbose: if ``True`` print additional details. Defaults to ``True``.</span>
<span class="sd">    :type verbose: ``bool``</span>
<span class="sd">    :return:</span>

<span class="sd">        * If ``divvy_rule`` is a string:</span>

<span class="sd">          * If ``action=&#39;copy&#39;`` and ``train_val_test_dict`` is not dictionary, this function will</span>
<span class="sd">            return a dictionary of the form ``{divvy_rule: [cache_file_path, cache_file_path, ...], ...}``.</span>

<span class="sd">        * If ``divvy_rule`` is a function:</span>

<span class="sd">          * If ``action=&#39;copy&#39;`` and ``train_val_test_dict`` is not a dictionary, this function will</span>
<span class="sd">            return a dictionary of the form ``{string returned by divvy_rule(): [cache_file_path, cache_file_path, ...], ...}``.</span>

<span class="sd">          * If ``action=&#39;ndarray&#39;`` and ``train_val_test_dict`` is not a dictionary, this function will</span>
<span class="sd">            return a dictionary of the form ``{string returned by divvy_rule(): array([Image Matrix, Image Matrix, ...]), ...}``.</span>

<span class="sd">          * If ``train_val_test_dict`` is a dictionary, the output is powered by utilities.train_val_test</span>
<span class="sd">            (available :func:`here &lt;biovida.support_tools.utilities.train_val_test&gt;`).</span>

<span class="sd">    :rtype: ``dict``</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from biovida.images import image_divvy</span>
<span class="sd">    &gt;&gt;&gt; from biovida.images import OpeniInterface</span>

<span class="sd">    |</span>
<span class="sd">    | **Obtain Images**</span>

<span class="sd">    &gt;&gt;&gt; opi = OpeniInterface()</span>
<span class="sd">    &gt;&gt;&gt; opi.search(image_type=[&#39;mri&#39;, &#39;ct&#39;])</span>
<span class="sd">    &gt;&gt;&gt; opi.pull()</span>

<span class="sd">    |</span>
<span class="sd">    | **Usage 1a**: Copy Images from the Cache to a New Location</span>

<span class="sd">    &gt;&gt;&gt; image_divvy(opi, divvy_rule=&quot;/your/output/path/here/output&quot;, action=&#39;copy&#39;)</span>

<span class="sd">    |</span>
<span class="sd">    | **Usage 1b**: Converting to ``ndarrays``</span>

<span class="sd">    &gt;&gt;&gt; def my_divvy_rule1(row):</span>
<span class="sd">    &gt;&gt;&gt;     if isinstance(row[&#39;image_modality_major&#39;], str):</span>
<span class="sd">    &gt;&gt;&gt;         if &#39;mri&#39; == row[&#39;image_modality_major&#39;]:</span>
<span class="sd">    &gt;&gt;&gt;             return &#39;mri&#39;</span>
<span class="sd">    &gt;&gt;&gt;         elif &#39;ct&#39; == row[&#39;image_modality_major&#39;]:</span>
<span class="sd">    &gt;&gt;&gt;             return &#39;ct&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; nd_data = image_divvy(opi, divvy_rule=my_divvy_rule1, action=&#39;ndarray&#39;)</span>

<span class="sd">    The resultant ``ndarrays`` can be extracted as follows:</span>

<span class="sd">    &gt;&gt;&gt; ct_images = nd_data[&#39;ct&#39;]</span>
<span class="sd">    &gt;&gt;&gt; mri_images = nd_data[&#39;mri&#39;]</span>

<span class="sd">    |</span>
<span class="sd">    | **Usage 2a**: A Rule which Invariably Returns a Single Save Location for a Single Row</span>

<span class="sd">    &gt;&gt;&gt; def my_divvy_rule2(row):</span>
<span class="sd">    &gt;&gt;&gt;     if isinstance(row[&#39;image_modality_major&#39;], str):</span>
<span class="sd">    &gt;&gt;&gt;         if &#39;mri&#39; == row[&#39;image_modality_major&#39;]:</span>
<span class="sd">    &gt;&gt;&gt;             return &#39;/your/path/here/MRI_images&#39;</span>
<span class="sd">    &gt;&gt;&gt;         elif &#39;ct&#39; == row[&#39;image_modality_major&#39;]:</span>
<span class="sd">    &gt;&gt;&gt;             return &#39;/your/path/here/CT_images&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; image_divvy(opi, divvy_rule=my_divvy_rule2, action=&#39;copy&#39;)</span>

<span class="sd">    |</span>
<span class="sd">    | **Usage 2b**: A Rule which can Return Multiple Save Locations for a Single Row</span>

<span class="sd">    &gt;&gt;&gt; def my_divvy_rule2(row):</span>
<span class="sd">    &gt;&gt;&gt;     locations = list()</span>
<span class="sd">    &gt;&gt;&gt;     if isinstance(row[&#39;image_modality_major&#39;], str):</span>
<span class="sd">    &gt;&gt;&gt;         if &#39;leg&#39; in row[&#39;abstract&#39;]:</span>
<span class="sd">    &gt;&gt;&gt;             locations.append(&#39;/your/path/here/leg_images&#39;)</span>
<span class="sd">    &gt;&gt;&gt;         if &#39;pelvis&#39; in row[&#39;abstract&#39;]:</span>
<span class="sd">    &gt;&gt;&gt;             locations.append(&#39;/your/path/here/pelvis_images&#39;)</span>
<span class="sd">    &gt;&gt;&gt;     return locations</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; image_divvy(opi, divvy_rule=my_divvy_rule2, action=&#39;copy&#39;)</span>

<span class="sd">    |</span>
<span class="sd">    | **Usage 3**: Divvying into *train/validation/test*</span>

<span class="sd">    **i**. Copying to a New Location (reusing ``my_divvy_rule1``)</span>

<span class="sd">    &gt;&gt;&gt; train_val_test_dict = {&#39;train&#39;: 0.7, &#39;test&#39;: 0.3, &#39;target_dir&#39;: &#39;/your/path/here/output&#39;}</span>
<span class="sd">    &gt;&gt;&gt; image_divvy(opi, divvy_rule=my_divvy_rule1, action=&#39;copy&#39;, train_val_test_dict=train_val_test_dict)</span>

<span class="sd">    **ii**. Obtaining ``ndarrays`` (numpy arrays)</span>

<span class="sd">    &gt;&gt;&gt; train_val_test_dict = {&#39;train&#39;: 0.7, &#39;validation&#39;: 0.2, &#39;test&#39;: 0.1}</span>
<span class="sd">    &gt;&gt;&gt; tvt = image_divvy(opi, divvy_rule=my_divvy_rule1, action=&#39;ndarray&#39;, train_val_test_dict=train_val_test_dict)</span>

<span class="sd">    The resultant ``ndarrays`` can be unpacked as follows:</span>

<span class="sd">    &gt;&gt;&gt; train_ct, train_mri = tvt[&#39;train&#39;][&#39;ct&#39;], tvt[&#39;train&#39;][&#39;mri&#39;]</span>
<span class="sd">    &gt;&gt;&gt; val_ct, val_mri = tvt[&#39;validation&#39;][&#39;ct&#39;], tvt[&#39;validation&#39;][&#39;mri&#39;]</span>
<span class="sd">    &gt;&gt;&gt; test_ct, test_mri = tvt[&#39;test&#39;][&#39;ct&#39;], tvt[&#39;test&#39;][&#39;mri&#39;]</span>

<span class="sd">    .. note::</span>

<span class="sd">        If a function passed to ``divvy_rule`` returns a system path when a dictionary has been passed</span>
<span class="sd">        to ``train_val_test_dict``, only the basename of the system path will be used.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        While it is possible to pass a function to ``divvy_rule`` which returns multiple categories</span>
<span class="sd">        (similar to ``my_divvy_rule2()``) when divvying into *train/validation/test*, doing</span>
<span class="sd">        so is not recommended. Overlap between these groups is likely to lead to erroneous</span>
<span class="sd">        performance metrics (e.g., accuracy) when assessing fitted models.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_image_divvy_error_checking</span><span class="p">(</span><span class="n">divvy_rule</span><span class="o">=</span><span class="n">divvy_rule</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">train_val_test_dict</span><span class="o">=</span><span class="n">train_val_test_dict</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;ImageProcessing&#39;</span><span class="p">:</span>
        <span class="n">data_frame</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">image_dataframe</span>
    <span class="k">elif</span> <span class="n">db_to_extract</span> <span class="o">==</span> <span class="s1">&#39;unify_against_images&#39;</span><span class="p">:</span>
        <span class="n">data_frame</span> <span class="o">=</span> <span class="n">instance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_frame</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">db_to_extract</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a DataFrame.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Got an object of type: &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span>
                        <span class="s2">&quot;`db_to_extract` may be invalid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data_frame</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="n">column_to_use</span> <span class="o">=</span> <span class="n">_divvy_column_selector</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">image_column</span><span class="o">=</span><span class="n">image_column</span><span class="p">,</span> <span class="n">data_frame</span><span class="o">=</span><span class="n">data_frame</span><span class="p">)</span>

    <span class="n">divvy_rule_wrapper</span> <span class="o">=</span> <span class="n">_image_divvy_wrappers_gen</span><span class="p">(</span><span class="n">divvy_rule</span><span class="o">=</span><span class="n">divvy_rule</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span>
                                                   <span class="n">train_val_test_dict</span><span class="o">=</span><span class="n">train_val_test_dict</span><span class="p">,</span>
                                                   <span class="n">column_to_use</span><span class="o">=</span><span class="n">column_to_use</span><span class="p">,</span> <span class="n">create_dirs</span><span class="o">=</span><span class="n">create_dirs</span><span class="p">,</span>
                                                   <span class="n">allow_overwrite</span><span class="o">=</span><span class="n">allow_overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">divvy_rule_apply</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Applying Divvy Rule...&quot;</span><span class="p">)</span>
        <span class="n">divvy_info</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">data_frame</span><span class="o">.</span><span class="n">iterrows</span><span class="p">(),</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">data_frame</span><span class="p">)):</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">divvy_rule_wrapper</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">divvy_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_divvy_info_to_dict</span><span class="p">(</span><span class="n">divvy_info</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">divvy_info</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">divvy_info</span> <span class="o">=</span> <span class="n">divvy_rule_apply</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divvy_info</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_val_test_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_image_divvy_train_val_test_wrapper</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">divvy_info</span><span class="o">=</span><span class="n">divvy_info</span><span class="p">,</span>
                                                   <span class="n">train_val_test_dict</span><span class="o">=</span><span class="n">train_val_test_dict</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divvy_info</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;ndarray&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_file_paths_dict_to_ndarrays</span><span class="p">(</span><span class="n">divvy_info</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divvy_info</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;copy&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">divvy_info</span></div>






















</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017, Tariq A. Hassan.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>